use reqwest::Method;
use serde::{ Deserialize, Serialize };
use snafu::{ ensure, ResultExt };
use std::fmt;

use crate::{ error, util, Alpaca, Result };

/// The side of the order - buy or sell
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(rename_all = "snake_case")]
pub enum OrderSide {
   /// An order to 'buy'
   Buy,

   /// An order to 'sell'
   Sell
}

/// The current status of the order in its lifecycle
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(rename_all = "snake_case")]
pub enum OrderStatus {
   /// The order has been received by Alpaca, but hasnâ€™t yet been routed to the execution venue.
   Accepted,

   /// The order has been received by exchanges, and is evaluated for pricing.
   AcceptedForBidding,

   /// The order has been completed for the day (either filled or done for day), but remaining settlement calculations are still pending
   Calculated,

   /// The order has been canceled and no further updates will occur for the order.  This can be either due to a cancel request
   /// by the user, or the order has been canceled by the exchanges due to its time-in-force.
   Canceled,

   /// The order is done executing for he day, and will not recieve further updates until the next trading day.
   DoneForDay,

   /// The order has expired, and no further updates will occur for the order.
   Expired,

   /// The order has been filled, and no further updates will occur for the order.
   Filled,

   /// The order has been received by Alpaca and routed to exchanges for execution.  This is the usual initial state of an order.
   New,

   /// The order has been parially filled.
   PartiallyFilled,

   /// The order is waiting to be cancelled.
   PendingCancel,

   /// The order has been received by Alpaca, and routed to the exchanges, but has not yet been accepted for execution.
   PendingNew,

   /// The order is waiting to be replaced by another order.  The order will reject cancel request while in this state.
   PendingReplace,

   /// The order has been rejected, and no further updates will occur for the order.
   Rejected,

   /// The order was replaced by another order, or was updated due to a market event such as corporate action.
   Replaced,

   /// The order has been stopped, and a trade is guaranteed for the order, usually at a stated price or better, but has not yet occurred
   Stopped,

   /// The order has been suspended, and is not eligible for trading.
   Suspended
}

/// The type of the order
#[derive(Clone, Debug, Deserialize, PartialEq, Serialize)]
#[serde(rename_all = "snake_case")]
pub enum OrderType {
   /// Buy or sell a security at a specified price or better.
   Limit,

   /// Buy or sell a security at the best available price in the current market.
   Market,

   Stop,
   StopLimit
}

/// The instruction used when placing a trade to indicate how long the order will remain active before it
/// is executed or expires.
#[derive(Clone, Debug, Deserialize, PartialEq, Serialize)]
#[serde(rename_all = "lowercase")]
pub enum TimeInForce {
   CLS,

   /// A day order is eligible for execution only on the day it is live. 
   DAY,

   /// A Fill or Kill order is only executed if the entire order quantity can be filled, otherwise the order is canceled.
   FOK,

   /// The order is good until canceled. Non-marketable GTC limit orders are subject to price adjustments to offset
   /// corporate actions affecting the issue. We do not currently support Do Not Reduce(DNR) orders to opt out of
   /// such price adjustments.
   GTC,

   /// An Immediate Or Cancel order requires all or part of the order to be executed immediately.
   /// Any unfilled portion of the order is canceled
   IOC,
   OPG
}
impl fmt::Display for TimeInForce {
   fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { write!(f, "{:?}", self) }
}

/// A unique order in the system.
///
/// Each order has a unique identifier provided by the client. This client-side unique order ID will be
/// automatically generated by the system if not provided by the client, and will be returned as part of
/// the order object along with the rest of the fields described below. Once an order is placed, it can
/// be queried using the client-side order ID to check the status.
#[derive(Clone, Debug, Deserialize)]
pub struct Order {
   /// Order ID - a UUID
   pub id: String,

   /// Asset class
   pub asset_class: String,

   /// Client unique order id
   pub client_order_id: String,

   /// If true, eligible for execution outside regular trading hours.
   #[serde(rename = "extended_hours")] pub is_extended_hours: bool,

   /// Filled quantity
   #[serde(deserialize_with = "util::to_u32")] pub filled_qty: u32,

   /// Filled average price
   #[serde(deserialize_with = "util::to_optional_f64")] pub filled_avg_price: Option<f64>,

   /// Limit price
   #[serde(deserialize_with = "util::to_optional_f64")] pub limit_price: Option<f64>,

   /// Type of order
   #[serde(rename = "type")] pub order_type: OrderType,

   /// Ordered quantity
   #[serde(deserialize_with = "util::to_u32")] pub qty: u32,

   /// Direction of trade - buy or sell
   pub side: OrderSide,

   /// The status of the order
   pub status: OrderStatus,

   //// Stop price
   #[serde(deserialize_with = "util::to_optional_f64")] pub stop_price: Option<f64>,

   /// Asset symbol
   pub symbol: String,

   /// how long the order is open for
   pub time_in_force: TimeInForce,
}
impl Order {
   /// Attempts to cancel this order. If the order is no longer cancelable (example: status=order_filled),
   /// an error will be generated.
   ///
   /// # Example
   ///
   /// To cancel an open order:
   ///
   /// ``` no run
   /// let alpaca = Alpaca::live("KEY_ID", "SECRET").await.unwrap();
   /// let open_order = ...; // some buy 
   ///
   /// open_order.cancel().await?;
   /// ```
   pub async fn cancel(&self, alpaca: &Alpaca) -> Result<()> {
      let response = alpaca.request(Method::DELETE, format!("v2/orders/{}", self.id).as_str())?
         .send().await.context(error::RequestFailed)?;

      if response.status().is_success() { return Ok(()) }
      match response.status().as_u16() {
         404 => error::OrderNotFound { order_id: self.id.clone() }.fail()?,
         422 => error::OrderNotCancelable { order_id: self.id.clone() }.fail()?,
         _ => error::Unknown.fail()?
      }
   }

   /// Attempts to replace this open order.  Will fail if the order is not open or the user does not have
   /// enough buying power to execute it.
   ///
   /// # Example
   ///
   /// To update the limit price of an open order to $100.0:
   ///
   /// ``` no run
   /// let alpaca = Alpaca::live("KEY_ID", "SECRET").await.unwrap();
   /// let open_order = ...; // some buy 
   ///
   /// open_order.update()
   ///    .limit_price(100.0)
   ///    .place(&alpaca).await.unwrap();
   /// ```
   pub fn update(&self) -> OrderUpdater {
      OrderUpdater { id: self.id.clone(), ..Default::default() }
   }

   /// Gets a list of all open orders - returns an empty vector if there are no open orders
   pub async fn get_open(alpaca: &Alpaca) -> Result<Vec<Order>> {
      let response = alpaca.request(Method::GET, "v2/orders")?
         .query(&[("status", "open")])
         .send().await.context(error::RequestFailed)?;

      ensure!(response.status().is_success(), error::InvalidCredentials);

      Ok(response.json::<Vec<Order>>().await.context(error::BadData)?)
   }

   /// Requests a new 'buy' order.
   ///
   /// # Example
   ///
   /// To buy 100 shares of AAPL at a limit price of $100.0 before the end of today:
   ///
   /// ``` no run
   /// let alpaca = Alpaca::live("KEY_ID", "SECRET").await.unwrap();
   ///
   /// let order = Order::buy("AAPL", 100, OrderType::Limit, TimeInForce::DAY)
   ///    .limit_price(100.0)
   ///    .place(&alpaca).await.unwrap();
   /// ```
   pub fn buy(symbol: &str, qty: u32, order_type: OrderType, time_in_force: TimeInForce) -> OrderBuilder {
      OrderBuilder { symbol: symbol.to_string(), qty: qty, side: OrderSide::Buy, order_type: order_type, time_in_force: time_in_force, ..Default::default() }
   }

   /// Requests a new 'sell' order.
   ///
   /// # Example
   ///
   /// To sell 100 shares of MSFT at market price before the end of today:
   ///
   /// ``` no run
   /// let alpaca = Alpaca::live("KEY_ID", "SECRET").await.unwrap();
   ///
   /// let order = Order::sell("MSFT", 100, OrderType::Market, TimeInForce::DAY)
   ///    .place(&alpaca).await.unwrap();
   /// ```
   pub fn sell(symbol: &str, qty: u32, order_type: OrderType, time_in_force: TimeInForce) -> OrderBuilder {
      OrderBuilder { symbol: symbol.to_string(), qty: qty, side: OrderSide::Sell, order_type: order_type, time_in_force: time_in_force, ..Default::default() }
   }
}

/// Builds up a new order and has the logic to submit the order
///
/// This structure is not create directly - but is returned from Order.buy or Order.sell
#[derive(Debug, Serialize)]
pub struct OrderBuilder {
   /// Defaults to false; if true the order will be eligible to execute in premarket/afterhours.
   /// Only valid with order_type of Limit and time_in_force of DAY.
   extended_hours: bool,

   /// Required if the order_type is Limit or StopLimit
   #[serde(skip_serializing_if = "Option::is_none", serialize_with = "util::to_optional_string")] limit_price: Option<f64>,

   /// The type of the order
   #[serde(rename(serialize="type"))] order_type: OrderType,

   /// Number of shares to trade
   #[serde(serialize_with = "util::to_string")] qty: u32,

   /// The side of the trade - buy or sell
   side: OrderSide,

   /// Required if order_type is Stop or StopLimit
   #[serde(skip_serializing_if = "Option::is_none", serialize_with = "util::to_optional_string")] stop_price: Option<f64>,

   /// Symbol or asset ID to identify the asset to trade
   symbol: String,

   /// How long the order will stay in effect
   time_in_force: TimeInForce,
}
impl OrderBuilder {
   /// Sets the extended hours flag
   pub fn extended_hours(mut self, extended_hours: bool) -> OrderBuilder {
      self.extended_hours = extended_hours;
      self
   }

   /// Sets the price limit
   pub fn limit_price(mut self, limit_price: f64) -> OrderBuilder {
      self.limit_price = Some(limit_price);
      self
   }

   /// Sets the stop price
   pub fn stop_price(mut self, stop_price: f64) -> OrderBuilder {
      self.stop_price = Some(stop_price);
      self
   }

   /// Attempts to place the order.  Will fail if certain preconditions aren't met, including:
   ///  * Limit order with no limit price
   ///  * Stop order with no stop price
   ///  * Extended hours requested for non limit orders where time_in_force is not Day
   //
   //  Will also fail if the buying power or shares are not sufficient.
   pub async fn place(&self, alpaca: &Alpaca) -> Result<Order> {
      // pre-conditions
      if (self.order_type == OrderType::Limit || self.order_type == OrderType::StopLimit) && self.limit_price == None {
         error::OrderInvalid { reason: "Limit orders need a limit price.".to_string() }.fail()?
      }
      if (self.order_type == OrderType::Stop || self.order_type == OrderType::StopLimit) && self.stop_price == None {
         error::OrderInvalid { reason: "Stop orders need a stop price.".to_string() }.fail()?
      }
      if self.extended_hours && (self.order_type != OrderType::Limit && self.time_in_force != TimeInForce::DAY) {
         error::OrderInvalid { reason: "Extended hours only works with limit orders for today".to_string() }.fail()?
      }

      let response = alpaca.request(Method::POST, "v2/orders")?
         .json::<OrderBuilder>(self)
         .send()
         .await.context(error::BadData)?;

      if response.status().is_success() { return Ok(response.json::<Order>().await.context(error::BadData)?) }

      match response.status().as_u16() {
         403 => error::OrderForbidden.fail()?,
         _ => error::Unknown.fail()?
      }
   }
}
impl Default for OrderBuilder {
   fn default() -> Self {
      OrderBuilder {
         symbol: "".to_string(),
         extended_hours: false,
         qty: 0,
         side: OrderSide::Buy,
         order_type: OrderType::Market,
         time_in_force: TimeInForce::DAY,
         limit_price: None,
         stop_price: None
      }
   }
}

/// Builds up a replacement order and has the logic to submit it.
///
/// This structure is not create directly - but is returned from Order.update
#[derive(Debug, Default, Serialize)]
pub struct OrderUpdater {
   /// The id of the order to replace
   #[serde(skip_serializing)] id: String,

   /// Required if the order_type is Limit or StopLimit
   #[serde(skip_serializing_if = "Option::is_none", serialize_with = "util::to_optional_string")] limit_price: Option<f64>,

   /// The number of shares to trade
   #[serde(skip_serializing_if = "Option::is_none", serialize_with = "util::to_optional_string")] qty: Option<u32>,

   /// Required if order_type is Stop or StopLimit
   #[serde(skip_serializing_if = "Option::is_none", serialize_with = "util::to_optional_string")] stop_price: Option<f64>,

   /// How long the order will stay in effect
   #[serde(skip_serializing_if = "Option::is_none", serialize_with = "util::to_optional_string")] time_in_force: Option<TimeInForce>,
}
impl OrderUpdater {
   /// Sets the price limit
   pub fn limit_price(mut self, limit_price: f64) -> OrderUpdater {
      self.limit_price = Some(limit_price);
      self
   }

   /// Sets the number of shares to trade
   pub fn qty(mut self, qty: u32) -> OrderUpdater {
      self.qty = Some(qty);
      self
   }

   /// Sets the stop price
   pub fn stop_price(mut self, stop_price: f64) -> OrderUpdater {
      self.stop_price = Some(stop_price);
      self
   }

   /// Sets the time the order is valid for
   pub fn time_in_force(mut self, time_in_force: TimeInForce) -> OrderUpdater {
      self.time_in_force = Some(time_in_force);
      self
   }

   /// Attempts to replace the order.
   pub async fn place(&self, alpaca: &Alpaca) -> Result<Order> {
      let response = alpaca.request(Method::PATCH, format!("v2/orders/{}", self.id).as_str())?
         .json::<OrderUpdater>(self)
         .send()
         .await.context(error::BadData)?;

      if response.status().is_success() { return Ok(response.json::<Order>().await.context(error::BadData)?) }

      match response.status().as_u16() {
         403 => error::OrderForbidden.fail()?,
         _ => error::Unknown.fail()?
      }
   }   
}